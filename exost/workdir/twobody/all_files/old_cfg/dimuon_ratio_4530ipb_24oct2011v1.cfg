[Variables]

# observable
mass = [1000.0, 200, 3000];
obs_set = set(mass);

# signal parameters
peak     = [1000.0, 200, 3000]; fix;
width_p0 = [-1.2979]; fix;
width_p1 = [0.0309338]; fix;

#AN-11-222 fig 18 as of Jul 7, 2011 confirmed by Jordan
res_p0   = [0.009332]; fix;
res_p1   = [0.0000571]; fix;
res_p2   = [-0.000000001171]; fix;

# background parameters
# Nick Kypreos, July 7, 2011
a = [-0.002423]; fix;
b = [-3.625]; fix;

# parameter of interest
ratio = [0.0, 0.0, 0.05]; float;

# other model parameters
# lumi     = [2940.00]; fix;
# Gena Kukartsev, scale 2.94/fb->4.53/fb, coeff=1.5408
nbkg_est = [4622.0]; fix;
# background-subtracted (?),Alexander Lanyov, Oct 23, 2011
nz       = [453965.0]; fix;


# exponent/eff_z
# Alexander Lanyov, Sep 28, 2011
# (0.001/0.099)
nsig_scale = [0.0101010]; fix;

# eff*acc SSM Z'
# Jordan, June 22, 2011
# scale not needed for ratio
#eff_scale = [1.048]; fix;
eff_scale = [1.0]; fix;
# Jordan, June 21, 2011
#eff_a     = [0.907]; fix;
#eff_b     = [-84.8]; fix;
#eff_c     = [16.6]; fix;
# Jordan, July 7, 2011 - different parameterization!!!
eff_a     = [0.86]; fix;
eff_b     = [-141000000.0]; fix;
eff_c     = [567.0]; fix;

# eff*acc KK graviton
eff_p0   = [0.901]; fix;
eff_p1   = [-830000.0]; fix;
eff_p2   = [-.0000188]; fix;

# systematics (lognormal)
# JP forwarded email by Dan Marlow June 22, 2011
# lumi_kappa = [1.06]; fix;
# Jordan, June 22, 2011
nsig_kappa = [1.031]; fix;
nbkg_kappa = [1.20]; fix;
#mass_kappa = [1.01]; fix;

# parameter of interest
poi_set = set(ratio);

# global observables
nom_nsig_nuis = [1.0, 0.1, 1.9]; fix;
nom_nbkg_nuis = [1.0, 0.1, 1.9]; fix;
nom_mass_nuis = [1.0, 0.1, 1.9]; fix;
global_obs_set = set(nom_nsig_nuis, nom_nbkg_nuis);

# nuisance parameters
nsig_nuis = [1.0, 0.3, 1.7]; float;
nbkg_nuis = [1.0, 0.0, 2.0]; float;
mass_nuis = [1.0, 0.9, 1.1]; fix;
nuis_set  = set(nsig_nuis, nbkg_nuis);

# weight for loading data
weight = [1.0]; fix;

# dummy variables
# this is a workaround for the RooWorkspace limitation
# in resolving naming conflicts in embedded autogenerated
# code
res_c    = [0.901]; fix;
res_s    = [17.238]; fix;
res_n    = [0.0]; fix;



[Data]

# 2940/pb
#data = root(dimuon,  'Dimuon data', data/alexander_lanyov_dimuons-m200_2.94ifb_28sep2011v1.root, mass);

# 3.79/fb
#data = root(dimuon,  'Dimuon data', data/alexander_lanyov_dimuons-m200_3.79ifb_13oct2011v1.root, mass);

# 4.53/fb
data = root(dimuon,  'Dimuon data', data/alexander_lanyov_dimuons-m200_4.53ifb_23oct2011v1.root, mass);





[Model]
# eff*acc SSM Z'
#eff  = cexpr('eff_scale*(eff_a+eff_b/(peak+eff_c))', eff_scale, eff_a, eff_b, peak, eff_c);
# Jordan Tucker, July 7, 2011
# (dummy to accomodate combination with dielectrons)
eff_dummy  = cexpr('eff_scale*(eff_a+eff_b/(peak+eff_c))', eff_scale, eff_a, eff_b, peak, eff_c);
eff  = cexpr('eff_scale*(eff_a+eff_b/(peak+eff_c)/(peak+eff_c)/(peak+eff_c))', eff_scale, eff_a, eff_b, peak, eff_c);

# signal yield
nsig = prod(nsig_scale, ratio, nz, eff, nsig_nuis);

# background yield
nbkg = prod(nbkg_est, nbkg_nuis);

# background shape
bkgpdf = CEXPR('exp(mass*a)*pow(mass,b)', mass, a, b);

# bg shape cross checks
#bkgpdf = Uniform(mass);
#bkgpdf = SUM::bkgpdf(fbkg_flat[0,0,1]*Uniform::bkg_flat(mass),CEXPR::bkg_nom('exp(mass*a)*pow(mass,b)', mass, a, b));

# signal shape with resolution and energy scale
mass_scaled = prod(mass, mass_nuis);
width       = sum(width_p0, prod(width_p1,peak));
sigma_rel   = sum(res_p0, prod(res_p1,peak), prod(prod(res_p2,peak),peak));
sigma_rel_dummy = cexpr('0.01*sqrt(res_s*res_s/peak + res_n*res_n/peak/peak + res_c*res_c)', res_s, peak, res_n, res_c);
sigma       = prod(sigma_rel, peak);
sigpdf      = Voigtian(mass_scaled, peak, width, sigma);

# extended S+B likelihood, single channel
model_core = SUM(nsig*sigpdf, nbkg*bkgpdf);

# systematics PDFs
syst_nsig = Lognormal(nsig_nuis, nom_nsig_nuis, nsig_kappa);
syst_nbkg = Lognormal(nbkg_nuis, nom_nbkg_nuis, nbkg_kappa);
#syst_mass = Lognormal(mass_nuis, nom_mass_nuis, mass_kappa);

# full model pdf
model = PROD(model_core, syst_nsig);

# prior pdf
prior_ratio = Uniform(ratio);
prior = PROD(prior_ratio,syst_nbkg);





[Model Config]
name                = mc
model               = model
observables         = obs_set
global_observables  = global_obs_set
poi                 = poi_set
nuisance_parameters = nuis_set
prior               = prior




[MCMC Calculator]
action_name             = mcmc
model_config            = mc
data                    = data
ph_cache_size           = 100
confidence_level        = 0.95
left_side_tail_fraction = 0.0
n_bins                  = 100
burn_in_steps           = 500
number_of_iterations    = 10000
make_posterior_plot     = True

# 10000 iter, 500 burn in, 4.53/fb
#   0.001, 163s, peak = 1500 GeV
#   0.012, 123s, peak =  400 GeV
#
# 10000 iter, 500 burn in, 4.53/4.0/fb combined
#   0.0006, 528s, peak = 1500 GeV
#   0.013,  511s, peak =  400 GeV
#
# Z' limits between [1700,2150]
# GR limits between [1600,2000]
# Combined Z'       [1950,2300]
# Combined GR       [1800,2150]
#
# assuming 50K iter calculations, ~4 per hour, ~30 per 8 hour
#   want 50 calculations to average over, per mass point
#   run 25 calc per job (~6 hours each)
#   300-2500 with 50 GeV step: 45*2 jobs
#   1600-2250 with 50 GeV step: 14*2 jobs (for Z' mass limits)
#   1500-2100 with 50 GeV step: 13*2 jobs (for GR mass limits)
#
# combined
# assuming 50K iter calculations, ~12 per 8 hour job
#   want 50 calculations to average over, per mass point
#   run 12 calc per job (~8 hours each)
#    300-2500 with 50 GeV step: 45*4 = 180 jobs
#   1850-2400 with 50 GeV step: 12*4 =  48 jobs (for Z' mass limits)
#   1700-2250 with 50 GeV step: 12*4 =  48 jobs (for GR mass limits)
